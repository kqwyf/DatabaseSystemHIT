# 数据库系统

## 第1讲 初步认识数据库系统

### 表 (Table)

#### 表的术语

**表名**：表的名称。

**表标题（格式）**：每一列的列名。

**表内容（值）**：表的内容。

**行/元组/记录**：表中的一行。

**列/字段/属性/数据项**：表中的一列。列中分为**列名**与**列值**。

**关系模式**：表名与表标题的组合。

**表/关系**：表名、表标题与表内容的组合。

**数据库**：相互有关联关系的若干表的集合。

### 数据库系统（工作环境）

#### 构成五要素

**数据库(DB)**：相互有关联关系的数据的集合。

**数据库管理系统(DBMS)**：管理数据库的一种系统软件。

**数据库应用程序(DBAP)**：不同用户使用的完成某功能的应用程序。**通过DBMS来使用数据库**。

**数据库管理员(DBA)**：**直接使用DBMS**来创建与管理数据库的人员。

**计算机基本系统**：使得数据库系统能够正常运行的计算机系统。

### 数据库管理系统 (DBMS)

#### 功能（用户角度）

- **数据库定义**：定义数据库中表的**名称**、**标题（包括属性名称及对属性值的要求）**等。
  - DBMS提供一套**数据定义语言(DDL)**，用户使用DDL描述表的格式，并由DBMS创建数据库。
- **数据库操纵**：向数据库的表中增加/删除/更新数据，以及对数据进行查询/检索/统计等。
  - DBMS提供一套**数据操纵语言(DML)**，用户使用DML描述增、删、改、查等操作，并由DBMS执行。
- **数据库控制**：控制数据库中数据的使用，即用户权限。
  - DBMS提供一套**数据控制语言(DCL)**，用户使用DCL描述对数据库的控制，由DBMS实际进行控制。
- **数据库维护**：转储/恢复/重组/性能检测/分析等功能。
  - DBMS提供一系列用于维护数据库的程序，一般由数据库管理员使用和掌握。

#### 数据库语言

**数据定义语言(DDL)**：用于定义数据格式。

**数据操纵语言(DML)**：用于对数据进行操作。

**数据控制语言(DCL)**：用于对数据进行控制。

上述三种语言联合起来形成**SQL语言**，即结构化查询语言。

##### 特点

- 一条数据库语言语句相当于高级语言的一个或多个循环程序。
- 数据库语言分为**嵌入型**（可嵌入到高级语言中使用，高级语言在此称为宿主语言）、**交互型**（可与用户交互）、**双重型**。

#### 功能（系统角度）

从系统实现角度看，DBMS的功能为**形式→构造→自动化**。

一般而言，操作系统管理存储与缓冲区，DBMS管理索引/文件记录与操作实现算法。但**有一些DBMS可越过操作系统直接管理存储与缓冲区**。

DBMS在后台运行着一系列程序：

- **语言编译器**：将用数据库语言书写的内容翻译为DBMS可执行的命令。如DDL编译器。
- **查询优化与查询实现**：执行引擎及基本命令的不同执行算法，提高数据库检索速度。
- **数据存取与索引**：在存储器上高效存取数据。例如存储管理器，缓冲区管理区，索引/文件和记录管理器。
- **通信控制**：网络环境下操作数据库与传输数据。
- **事务管理**：提高可靠性，避免并发错误。
- **故障恢复**：使数据库自动恢复到故障发生前的正确状态。例如备份、运行日志操控。
- **安全性控制**：合法性检验，避免非授权非法用户访问数据库。
- **完整性控制**：检查数据及数据操作的正确性。
- **数据字典管理**：管理用户已经定义的信息。
- **应用程序接口**：使应用程序能够使用DBMS特定功能。
- **数据库数据装载、重组**
- **数据库性能分析**：统计运行过程中数据库的各种性能数据，便于优化。

## 第2讲 数据库系统的结构抽象与演变

### 数据库系统的标准结构

#### 数据（视图）与模式

**数据（视图）**：某一表现形式下表现出来的数据库中的数据。

**模式**：对数据库中数据进行的一种结构性描述。

#### 三级模式两层映像

数据库系统的标准结构包括**用户层次**、**概念层次**、**内部层次**。总结为如下三级模式，两层映像。

##### 三级模式

- **外部模式（用户模式）**：某一用户能够看到与处理的数据的结构描述，是全局数据的一部分。
- **概念模式（全局模式）**：从全局角度管理的数据的结构描述，包含相应的关联约束，体现数据间的内在本质联系。
- **内部模式（物理模式）**：存储在介质上的数据的结构描述，包含存储路径、存储方式、索引方式等。

通常，**模式**默认意为**全局模式**，**视图**默认意为**外部视图**。

##### 两层映像

- **E-C映像**（即External - Conceptual）：将外模式映射为概念模式，支持数据概念视图向外部视图的转换。
- **C-I映像**（即Conceptual - Internal）：将概念模式映射为内模式，支持数据概念视图向内部视图的转换。

DBMS通常允许**用户自定义三级模式**，而通过**程序自动实现两层映像**。

#### 两个独立性

使用数据库系统标准结构可获得两个独立性：

- **逻辑数据独立性**：概念模式变化时，可以不改变外部模式（只需改变E-C映像），从而无需改变应用程序。
- **物理数据独立性**：内部模式变化时，可以不改变概念模式（只需改变C-I映像），从而无需改变外部模式。

两个独立性的意义都在于不会因为存储结构与逻辑结构的变化而影响应用程序。

### 数据模型

**数据模型**：规定模式统一描述方式的模型，是对模式本身结构的抽象。

- **关系模型**：以**表**的形式组织数据。模式需包含表名及若干属性。
- **层次模型**：以**树**的形式组织数据。模式需以树形组织若干**实体型**，实体型间连线称为**系型**。
- **网状模型**：以**图**的形式组织数据。模型形式与层次模型相似，但允许每个节点有多个父节点与子节点。

其余还有面向对象模型、XML模型、NoSQL模型等。

### 数据库系统的演变与发展

#### 由文件系统到数据库

- 文件系统中，数据存取基本以**记录**为单位。
  - 优点：用户无需考虑文件存储的物理细节。
  - 缺点：数据的组织及语义与应用程序紧密相关；文件及文件的记录之间无联系。
- 数据库系统中，数据由DBMS统一存取。数据存取可以以**记录**为单位，也可以以**数据项**和**记录集合**为单位。
  - 意义：多个应用程序可共享数据及数据结构的操作；系统自动检查安全性、完整性和并发正确性；记录之间相互有关联。

#### 由层次模型数据库、网状模型数据库到关系数据库

- **第一代数据库**：**层次模型数据库**与**网状模型数据库**
  - 缺点：由指针系统维系，结构描述复杂；检索依赖于指针系统指示的路径；不能有效支持记录集合的操作。

- **第二代数据库**：**关系数据库**
  - 意义：结构描述简单；检索不依赖于路径信息或过程信息，支持非过程化的数据操作；有效支持记录集合的操作。

#### 由关系数据库到对象关系数据库、面向对象数据库

- 关系数据库需按**关系的第一范式**组织数据，即**数据项是不可再分**的。
- 对象-关系数据库以对象封装需分解的数据项（多值属性和复合属性）。面向对象数据库支持复杂的数据类型，数据封装与抽象数据结构，并支持面向对象的一些特性。
  - 意义：有效支持不满足关系第一范式的数据项。
- XML数据库被称为**半结构化数据库**，面向数据交换而提出，**数据**与**数据的语义**合并在一起存储处理。XML数据库在互联网中得到广泛应用。

#### 由多种多样的数据库到多数据库开放式互连

使用**开放数据库连接(ODBC)**与不同的DBMS交互，从而统一操作多种数据库。

## 第3讲 关系模型之基本概念

### 关系

**域**：一组值的集合，这组值具有相同的数据类型。域是列的取值范围。

**分量**：元组中的每一个值称为一个分量。

**关系**：一组域的笛卡尔积的子集（满足某种意义的子集）。

**属性名**：由于关系的不同列可能来自同一个域，故为每一列起一个名称，即属性名。注意**属性名与域名不同**。

**关系模式/表标题**：用于表示关系的结构，记为$R(A_1:D_1,A_2:D_2,\dots,A_n:D_n)$，可简记为$R(A_1,A_2,\dots,A_n)$。意为属性$A_i$对应于域$D_i$。其中$n$称作关系的**度**或**目**，关系中元组的数目称为关系的**基数**。在许多DBMS中，域一般直接说明为属性的类型、长度等。

**候选码/候选键**：能唯一标识任意一个元组的一个极小属性组（即从中去除任意一个属性便不满足这一性质）。当候选码由所有属性构成时，该关系称为**全码关系**。

**主码/主键**：当有多个候选码时，可以选定一个作为主码。

**主属性**：包含在任意一个候选码中的属性。

**外码/外键**：若一个属性组不是关系$R$的候选码，但与关系$S$的候选码相对应，则称该属性组为$R$的外码/外键。两个关系通常靠外码来连接。

#### 特性

- 关系的任意两个元组不能完全相同，但在现实应用中，**表可能并不完全遵守此特性**。
- **关系第一范式**：属性不可再分。**复合属性**（属性由多个子属性构成）和**多值属性**（同一元组中该属性有多个值）不符合关系第一范式。

### 关系模型

#### 关系模型的三要素

- **基本结构**：关系
- **关系操作**：
  - 基本操作：并，差，积，选择，投影。（有时也将“更名”操作视为基本操作之一）
  - 扩展操作：交，连接，除。
- **完整性约束**：包括**实体完整性**、**参照完整性**及**用户自定义的完整性**。其中，实体完整性和参照完整性由DBMS自动支持，用户自定义的完整性通常由DBMS在更新操作发生时自动检查。
  - **实体完整性**：主码中的属性值不能为空值（不知道或无意义的值，以“?”表示）。
  - **参照完整性**：外码要么取空值，要么取其对应主码关系中出现过的主码值。
  - **用户自定义的完整性**：用户针对具体应用定义的完整性约束条件。

## 第4讲 关系模型之关系代数

### 关系代数操作

#### 并相容性

- 两关系的属性数目相同。
- 两关系按顺序对应属性的域相同。

并、差、交操作需要操作对象满足**并相容性**。

#### 操作定义

- 集合操作：

  - **并（$\cup$）**：$R \cup S=\{t|t \in R \or t \in S\}$
  - **交（$\cap$）**：$R \cap S=\{t|t \in R \and t \in S\}$，或$R \cap S=R-(R-S)$
  - **差（$-$）**：$R-S=\{t|t \in R \and t \notin S\}$
  - **广义积（$\times$）**：$R \times S=\{<a_1,\dots,a_n,b_1,\dots,b_m>|<a_1,\dots,a_n> \in R \and <b_1,\dots,b_m> \in S\}$
    - 由于行位置无关性与列位置无关性，有$R \times S = S \times R$。
- 纯关系操作：

  - **投影（$\pi_A$）**：$\pi_{A_{i1},A_{i2},\dots,A_{ik}}(R)=\{<t[A_{i1}],t[A_{i2}]>,\dots,t[A_{ik}]|t \in R\}$

    - 投影结果的列顺序可以与原顺序不同。
    - 投影后若出现相同元组，应消除掉。
    - 下标若为关系名，则代指该关系拥有的属性；若为关系之差，则代指两关系的属性集之差。
  - **选择（$\sigma_{con}$）**：$\sigma_{con}(R)=\{t|t \in R \and con(t)=\rm{true}\}$

    - 书写条件时，元组$t$的分量$A_i$记为$t[A_i]$，或简写为$A_i$。
  - **连接**：

    - **$\theta$-连接（$\mathop \Join \limits_{A \space\theta\space B}$）**：$R \mathop \Join \limits_{A \space\theta\space B} S=\sigma_{t[A]\space\theta\space s[B]}(R \times S)$，其中$\theta$为比较运算符，$t \in R$，$s \in S$。
      - 一个关系与自身连接时应进行换名，例如$\rho_{S}R$表示将集合$R$换名为$S$。
    - **等值连接**：即特殊的$\theta$-连接，其中$\theta$为$=$。
    - **自然连接（$\Join$）**：$R \Join S=\sigma_{t[B]=s[B]}(R \times S)$，要求$R$与$S$中有若干个相同的属性（组）$B$。
      - 连接后去除重复属性列。
  - **除（$\div$）**：$R \div S=\{t[A]|t \in R \and \{t[A]\} \times S \subseteq R\}$，其中$A$为属于$R$但不属于$S$的属性（组）。
  - **外连接**：连接+失配的元组（与全空元组连接）
    - 分为左外连接、右外连接与全外连接，左/右代指保留哪个方向的失配元组，记号为相应方向多两横。
- 其它操作：
  - **去重（$\delta(R)$）**
  - **分组聚集（$\gamma(R)$）**
  - **排序（$\tau(R)$）**

## 第5讲 关系模型之关系演算

关系演算按照谓词变量的不同，分为**关系元组演算**与**关系域演算**。

### 关系元组演算

关系元组演算表达式的基本形式：$\{t|P(t)\}$，表示所有使谓词$P$为真的元组$t$的集合。其中谓词$P$有递归定义，允许使用的运算符包括$\in$，$\theta$，$\neg$，$\and$，$\or$，$\exist()()$，$\forall()()$。其中，被存在量词$\exist$或全称量词$\forall$限定的元组变量称为**约束变量**，否则称为**自由变量**。

存在量词与全称量词的等价转换：

- $\forall(t \in R)(P(t)) \Leftrightarrow \neg (\exist (t \in P)(\neg P(t)))$
- $\exist(t \in R)(P(t)) \Leftrightarrow \neg (\forall (t \in P)(\neg P(t)))$

### 关系域演算

关系域演算表达式的基本形式：$\{<x_1,x_2,\dots,x_n>|P(x_1,x_2,\dots,x_n)\}$，表示所有使谓词$P$为真的域变量元组的集合。其中$x_i$为域变量或常量，$P$具有与关系元组演算公式相似的递归定义。

#### QBE语言

通过填表进行基于关系域演算的增删改查。

QBE操作框架四部分：关系名，属性名，操作命令，查询条件。

示例元素：用于连接多个条件。当两行间使用不同示例元素时表示或；当两行间使用相同示例元素时表示与；当两表中出现相同示例元素时表示连接两表中对应的属性。

操作命令也可写在查询条件区，表示仅操作该列；与或非运算符也可写在操作命令区，此时将整行看做一个条件（相当于加括号）。

### 关系运算的安全性

安全性：不产生**无限关系**和**无穷验证**的运算称为安全的。

关系代数是有限集合的运算，故是**安全**的；关系演算**不一定是安全**的。

**安全约束有限集合 (DOM) **：$\rm{DOM}(\psi)$是一个有限集，其中每个元素要么是公式$\psi$中的符号，要么是$\psi$中某关系中某元组的某分量。DOM不必是最小集合。

**安全元组演算表达式**：满足以下条件的元组演算表达式$\{t|\psi(t)\}$称为安全表达式。

- 若$t$满足$\psi$，则$t$的每个分量均属于$\rm{DOM}(\psi) $。（保证不产生无限关系）
- 对于$\psi$中形如$(\exist u)(\omega(u))$的子表达式，若$u$满足$\omega$，则$u$的每个分量均属于$\rm{DOM}(\omega)$。（保证不产生存在量词的无穷验证）
- 对于$\psi$中形如$(\forall u)(\omega(u))$的子表达式，若$u$不满足$\omega$，则$u$的每个分量均属于$\rm{DOM}(\omega)$。（保证不产生全称量词的无穷验证）

## 第6-8讲 SQL语言

SQL语言是集DDL、DML、DCL于一体的数据库语言。

### 操作语句

#### DDL操作

- **Create**

  - create database 数据库名;

    创建指定名称的数据库。在创建数据库后，即可在其中创建表。

  - create table 表名(列名 数据类型 \[default \{默认值|Null\}\] \[列约束\] \[\[, 列名 数据类型 \[default \{默认值|Null\}\] \[列约束\]\] ...\]\[, 表约束\]);

    创建指定名称的表，包含指定的属性列，每个属性具有指定的数据类型及可能的默认值与约束。

    - 列约束：\{Not Null|\[constraint 约束名\] \{Unique|Primary key|check (条件)|references 表名\[(列名)\] \[on delete \{Cascade|Set Null\}\]\}\}

      Primary key：**主键约束**，即指定该属性为主键。**每个表仅能包含一个主键约束**。

      Unique：**唯一性约束**，即指定该属性为候选键。每个表可以有多个唯一性约束。

      Not null：**非空约束**，即指定该属性列不允许出现空值。

      check：该列更新时应满足check规定的条件。条件形式同where（其中可包含子查询）。

      references：定义该列为指定表的外键，可在其后指定对应指定表的哪一列。

      on delete：当上述外键对应列某值v被删除时，应如何处理该外键。Cascade表示删除本表中外键为v的元素；Set Null表示将本表中外键为v的元素外键值更新为Null。若无on delete条件则无操作。

    - 表约束：\[constraint 约束名\] \{Unique (列名\[\[, 列名\] ...\])|Primary key (列名\[\[, 列名\] ...\])|check (条件)|Foreign key (列名\[\[, 列名\] ...\]) references 表名 \[(列名\[\[, 列名\] ...\])\] \[on delete Cascade\]\}

  - create view 视图名 \[(列名\[\[, 列名\] ...\])\] as (子查询) \[自定义约束条件\];

    创建指定结构的**视图（外模式）及其E-C映像**，以及用户对元组的自定义约束。当使用DML操作更新元组时，DBMS将自动检查自定义约束是否被满足。

  - create assertion 断言名 check 条件;

    创建断言时及数据库每次更新时，DBMS将检查断言。断言将增加DBMS负担，降低效率。

  - create trigger 触发器名 \{before|after\} \{insert|delete|update \[of 列名\[\[, 列名\] ...\]\]\} on 表名 \[referencing 变量定义\[\[, 变量定义\] ...\]\] \[for each row|for each statement\] \[when (条件)\] \{语句|begin atomic 多行语句 end\};

    before/after：指定在动作执行前或执行后触发。

    for each row / for each statement：指定对每一条记录的修改均触发或对一条SQL语句触发。

    - 变量定义：\{old \[row\] \[as\] 旧元组命名|new \[row\] \[as\] 新元组命名|old table \[as\] 旧表名|new table \[as\] 新表名\}

      用于在条件或语句中引用变量。

- **Alter**

  - alter table 表名 add \{(列名 数据类型 \[default \{默认值|Null\}\]\[\[, 列名 数据类型 \[default \{默认值|Null}]\] ...\][, 表约束])|constraint 约束名\};

  - alter table 表名 drop \{column (列名\[\[, 列名\] ...\])|constraint 约束名|Primary key\};

  - alter table 表名 modify 列名 数据类型 \[default \{默认值|Null\}\] \[列约束]\[\[, 列名 数据类型 \[default \{默认值|Null\}\] \[列约束\]\] ...\];

    修改指定表的定义。add用于增加列或约束，drop用于删除列或约束，modify用于修改列的定义。

    **未命名的约束无法被删除。**

- **Drop**

  - drop table 表名;

    对指定的表删除包括表格式、表中所有元组、由该表导出的视图等所有相关内容。

  - drop database 数据库名;

    删除指定数据库。

  - drop view 视图名;

    删除指定视图。

- Use（仅部分DBMS）

  - use 数据库名;

    在允许操作多个数据库的DBMS中，指定待操作数据库。

- Close（仅部分DBMS）

  - close 数据库名;

    在允许操作多个数据库的DBMS中，关闭数据库。

#### DML操作

- **Insert**

  - insert into 表名\[(列名 \[\[, 列名\] ...\])\] values (值 \[\[, 值\] ...\]);

    向指定表的指定列插入记录。当省略所有列名时，默认表示表中依存储顺序排列的所有列。values后面值的顺序需与语句中的列名顺序一致。

  - insert into 表名\[(列名 \[\[, 列名\] ...\])\] 子查询;

    向指定表的指定列插入子查询结果中的若干元组。

- **Delete**

  - delete from 表名 \[where 条件表达式\];

    删除指定表中满足指定条件的元组。若省略条件，则删除所有元组。

- **Update**

  - update 表名 set 列名=表达式|(子查询)\[\[, 列名= 表达式|(子查询)\] ...\] \[where 条件表达式\];

    更新指定表中满足指定条件的元组的指定列为新的值。新值表达式中可包含属性名及数学符号。

- **Select**

  - select \[Distinct\] 列名\[\[ as\] 别名\] \[\[, 列名\[\[ as\] 别名\]\] ...\] from 表名\[\[ as\] 别名\] \[\[, 表名\[\[ as\] 别名\]\] ...\] \[where 检索条件\] \[group by 分组条件 \[having 分组过滤条件\]\] \[order by 列名 \[asc|desc\]\];

    从表名所给出的表（的笛卡尔积）中，查询满足检索条件的元组，并按照指定的列及其顺序投影显示。相当于$\pi_{列名,\dots, 列名}(\sigma_{检索条件}(表名))$。列名可用“*”表示所有列。检索条件中可使用运算符and、or、not及括号，模糊匹配运算like或not like，空值判断is \[not\] null，以及子查询（详见下文）；多个表中属性名相同时，以“表名.属性名”方式指定属性。列名处也可填写计算表达式及聚集函数，详见下文。

    模糊匹配：通配符“%”匹配零至多个字符；“_”匹配单个任意字符；“\”为转义符。

    属于：in后可跟随表或中间查询结果表。

    Distinct：去除投影后重复的元组。

    group by：将查询结果按某一列/某些列的值进行分组（相同值归为一组），以支持Select中的聚集函数。

    having：过滤出满足指定条件的分组。

    order by：查询结果依指定属性升序（asc）或降序（desc）排列。若省略顺序指定，默认为升序。所依据属性可以不在查询结果中。

**聚集函数**：select语句后除可跟随列名外还可跟随计算表达式或聚集函数。有5个内置聚集函数：

- count(任意变量)：求个数，参数可直接填“\*”。
- sum(数值类型变量)：求和。
- avg(数值类型变量)：求平均。
- max(数值或字符串类型变量)：求最大值。
- min(数值或字符串类型变量)：求最小值。

**子查询**：出现在where语句中的select语句称为子查询。子查询返回一个集合。实际使用中，除使用select语句外，也可直接使用枚举形式写出集合字面量作为返回值，即(元素, 元素, ...)形式。共有三种子查询：

- In子查询

  - 表达式 \[not\] in (子查询)

    判断表达式是否在子查询结果中。

    表达式：列名、常数等。

- $\theta$-Some / $\theta$-All子查询：

  - 表达式 $\theta$ \{some|all\} (子查询)

    some：判断表达式是否至少与子查询结果中某一个值满足$\theta$关系。“表达式 in (子查询)”与“表达式 = some (子查询)”是等价的。

    all：判断表达式是否与子查询结果中所有值均满足$\theta$关系。“表达式 not in (子查询)”与“表达式 <> all (子查询)”是等价的。

- Exists子查询：

  - \[not\] exists (子查询)

    判断子查询结果是否为空集。在不使用not时，往往exists语句也可一并省略。

**相关子查询**：内层查询依靠外层查询的某些参量的，称为相关子查询；否则（内层查询可独立进行的）称为非相关子查询。相关子查询使用的外层参量需要以**外层表名**进行**限定**。

子查询间可使用并交差运算，即union \[All\]、intersect \[All\]、except \[All\]，其中使用All关键字时，重复元组将被保留。进行运算的两子查询结果的**列必须按顺序对应**。

**连接运算**（高级语法）：在from子句中使用。语法为：表名\[Natural\] \[Inner|\{Left|Right|Full\} \[Outer\]\] join 表名 \{on 连接条件 | using (列名 \[\[, 列名\] ...\])\}。连接运算由两部分构成：

- 连接类型：
  - Inner Join：即$\theta$-连接运算。
  - Left Outer Join：即左外连接运算，左表中无法与右表匹配的元组将与空值元组连接。
  - Right Outer Join：即右外连接运算，右表中无法与左表匹配的元组将与空值元组连接。
  - Full Outer Join：前两者的并集。
- 连接条件：
  - Natural：即自然连接，仅连接在所有公共属性上均取值相等的元组。结果中公共属性仅出现一次。
  - On：即$\theta$-连接，On后可跟随连接条件。
  - Using：特殊的自然连接，Using后可指定依据哪些公共属性进行自然连接，指定的属性必须为所有公共属性的子集。

注：新增/删除/更新元组时，DBMS将检查完整性约束，若约束条件不满足，则不会执行动作。

注：视图不可更新的情形：

- select目标包含聚集函数
- select子句使用了unique或distinct
- 包括group by
- 包括经算术表达式计算得到的列
- 由单一表中的列构成，但未包括主键

注：现行DBMS的空值处理策略：

- 除is \[not\] null外，空值不满足任何查找条件。
- 有null参与的算术表达式值为null。
- 有null参与的比较运算值为false。
- 除count()外，其余聚集函数均会忽略空值。

#### DCL操作

- **Grant**

  - grant \{All privileges|权利\[\[, 权利\] ...\]\} on \[table\] \{表名|视图名\} to \{Public|用户账户\[\[, 用户账户\] ...\]\} \[With grant option\];

    授予指定用户指定权利。

    权利：取值范围为\{Select, Insert, Update, Delete, All privileges\}。

    With grant option：允许被授权者传播这些权利。

- **Revoke**

  - revoke \{All privileges|权利\[\[, 权利\] ...\]\} on \{表名|视图名\} from \{Public|用户账户\[\[, 用户账户\] ...\]\};

    收回指定用户的指定权利。

## 第8讲 数据库的完整性和安全性

关于完整性与安全性的SQL语句参见上一讲。

### 数据库完整性

**数据库完整性**：DBMS应保证的DB的在任何情况下的正确性、有效性和一致性。

- **广义完整性**：语义完整性、并发控制、安全控制、DB故障恢复等。
- **狭义完整性**：专指**语义完整性**。

**完整性约束条件**的一般形式：(O, P, A, R)

- O：数据集合，即约束的对象。
- P：谓词条件，即约束内容。
- A：触发条件，即何时检查。
- R：响应动作，即不满足条件时怎么办。

#### 完整性的分类

- 按**约束对象**分类
  - **域完整性约束条件**：对孤立列进行约束条件判断。
  - **关系（表）完整性约束条件**：对元组或关系内/关系间的若干元组间的联系进行约束条件判断。
- 按**约束来源**分类
  - **结构约束**：来自于模型的约束，只关心数值相等与否、是否允许空值等。如实体完整性与参照完整性。
  - **内容约束**：来自于用户的约束，关心元组或属性的取值范围。如用户自定义完整性。
- 按**约束状态**分类
  - **静态约束**：DB在任意时刻均应满足的约束。
  - **动态约束**：DB从一状态变为另一状态时应满足的约束。如限制属性值只升不降。

SQL支持静态约束中的**域完整性约束**与**表完整性约束**（仅需定义O与P），动态约束中的**触发器**机制（需定义O、P、A、R）。

### 数据库安全性

**数据库安全性**：DBMS应该保证的数据库免受非法、非授权用户的使用、泄露、更改或破坏的特性。

#### 安全性的分类

- 自主安全性机制：存取控制

  由用户自主传递权限。

- 强制安全性机制：

  对数据和用户进行强制分类，使不同用户能够访问不同类别的数据。

- 推断控制机制：

  防止从数据库公开信息通过推断获得私密信息。

#### 自主安全性机制

自主安全性访问规则的一般形式：(S, O, t, P)

- S：请求主体（用户）
- O：访问对象
- t：访问权利
- P：谓词（拥有权利需满足的条件）

控制方法：**按名控制**（仅涉及S、O、t），**按内容控制**（涉及S、O、t、P）。

实现方式：**存储矩阵**、**视图**。

##### 权利级别

1. 读
2. 更新（插入元组、更新元组、删除元组）
3. 创建（创建表等、更新表等、删除表等）

高级别权利自动包含低级别权利。

级别3权利称为**账户级别**权利，级别1和2称为**关系级别**权利。

## 第9-10讲 嵌入式SQL语言

### 基本概念

#### 静态SQL与动态SQL

静态SQL：SQL语句已在程序中写好，使用时仅需传递变量值。

动态SQL：SQL语句在程序中动态构造，形成字符串，然后交由DBMS执行，执行时仍可传递变量。

#### 数据字典

**数据字典**：又称**系统目录**或**元数据**，是系统维护的一些表或视图的集合，其中存储了数据库中各类对象的定义信息。数据字典可使用SQL语句访问。

组成：关系信息、用户账户信息（包括密码）、统计与描述性数据、物理文件组织信息、索引信息。

#### SQLDA

**SQLDA**：SQL描述区，内存数据结构，装载着关系模式的定义信息。不同DBMS提供的SQLDA格式并不一致。

#### 事务

**事务**：存取或改变数据库内容的程序的一次执行（一条或多条SQL语句的一次执行）。DBMS通过事务提供一致性状态转换。

##### 特性

- 原子性：保证事务的一组操作原子不可分。
- 一致性：保证事务的操作状态符合一致性操作规则。
- 隔离性：保证并发执行的多个事务之间互相不受影响。
- 持久性：保证已提交事务的影响是持久的。

#### 游标

**游标**：指向某检索记录集的指针，**只能单向移动**。游标读完全部记录时以EOF标识。

**可滚动游标**：由ODBC提供支持，**可在记录集上任意移动**。游标移动至记录集首时以BOF标识。

### 嵌入式SQL语句

- 变量声明：begin declare section; 类型 变量名 \[=初始化值\]; end declare section;

  以此方式声明的字符串长度不包括'\\0'。

- 数据库连接：

  - 连接：
    - connect to 目标服务器 as 连接名 user 用户名;
    - connect to default;
  - 断开连接：
    - disconnect 连接名;
    - disconnect current;

- 执行动态SQL语句：

  - 运行时编译并执行：

    - execute immediate :SQL语句字符串;

      立即编译执行的语句必须为完整SQL语句。

  - 先编译后执行：

    - 编译：prepare 语句名 from :SQL语句字符串;
    - 执行：execute 语句名 using :宿主变量;

- 提交/撤销执行：

  - 提交：commit work;
  - 撤销：rollback work;

  程序员需要通过提交/撤销语句确认事务结束。

- 游标：

  - declare 游标名 \[Scroll\] cursor for 查询语句;

    定义一个游标，但不执行查询语句。

    Scroll：加入该选项则定义可滚动游标。

  - open 游标名;

    执行游标对应的查询语句，并将游标指向结果首部。**游标可被多次打开**。

  - close 游标名;

    关闭游标。

- 数据交互：

  - 读取记录：

    - 单行记录：select 表达式 \[\[, 表达式\] ...\] into :宿主变量\[\[, :宿主变量\] ...\] ... ;

      将查询得到的单行结果直接赋值给宿主变量。注意**宿主变量前有引号**。

    - 多行记录：fetch \[Next|Prior|First|Last|\[Absolute|Relative\] 偏移量\] 游标名 into 宿主变量列表;

      使游标读出一条记录。

      对于可滚动游标，可使用语句中的可选项以控制游标移动。偏移量可正可负。

  - 删除记录：

    - 常规delete语句

    - delete ... where current of 游标名;

      删除游标所在位置的记录。

  - 更新记录：

    - 常规update语句

    - update ... where current of 游标名;

      更新游标所在位置的记录。

  - 插入记录：

    - 常规insert语句，**并无游标插入方式**。

- 状态捕获及错误处理：

  - include sqlca;

    设置SQL通信区，使宿主程序能与DBMS交流。

  - whenever 状态 动作;

    捕获状态并执行指定动作（如goto）。该语句定义的捕获作用域以同样的条件再次被定义捕获为止。

    由于条件捕获由预编译程序处理，故**作用域以代码区域为准，而非程序控制流**。

    常见状态：

    - SQLERROR：SQL语句出错。其具体意义依赖于DBMS。
    - NOT FOUND：执行SQL语句后无结果记录。
    - SQLWARNING：并非错误，但应引起注意的条件。

    常见动作：

    - continue：继续执行。
    - goto 标签：跳转至标签位置语句执行。
    - stop：终止程序执行，撤销当前事务，断开数据库连接。
    - do 函数/call 函数：调用宿主程序的函数。调用结束后返回触发条件的SQL语句之后继续执行。

  - 非SQL语句方法：

    - 状态记录变量：sqlcode、sqlca.sqlcode、sqlstate

      不同DBMS各自支持上述变量中的一种或几种，用于记录执行SQL语句的状态。

## 第10讲 数据库标准接口

### ODBC

**ODBC**：不同语言的应用程序与不同数据库服务器间通讯的标准。

**SQLCA**：SQL通讯区，记录着SQL语句被DBMS执行后返回的状态信息。

连接默认启用自动提交特性，自动提交每一条SQL语句，可手动关闭后手动提交。

连接步骤：

1. SQLAllocEnv()
2. SQLAllocConnect()
3. SQLConnect()
4. 进行工作：
   - 发送SQL命令：SQLExecDirect()
   - 获取结果：SQLFetch()
   - 绑定宿主变量与结果属性：SQLBindCol()
5. SQLDisconnect()
6. SQLFreeConnect()
7. SQLFreeEnv()

### JDBC

**JDBC**：提供Java应用程序与数据库服务器的连接和通讯能力。

常见类：

- java.sql.DriverManager：处理驱动的调入，支持产生新数据库连接。
- java.sql.Driver：通过驱动进行数据库访问。
- java.sql.Connection：对特定数据库的连接。
- java.sql.Statement：对特定的数据库执行的SQL语句。
- java.sql.PreparedStatement：用于执行预编译的SQL语句。
- java.sql.CallableStatement：用于执行对数据库内嵌过程的调用。
- java.sql.ResultSet：从当前执行的SQL语句中返回结果数据。

连接步骤：

1. 传递Driver给DriverManager加载数据库驱动。
2. 通过URL得到Connection对象，建立数据库连接。
3. 进行工作：
   - 使用Statement对象查询或修改数据库（查询和修改使用不同的函数）。
   - 查询返回ResultSet对象。
   - 使用结束后关闭Statement对象。
4. 关闭连接。

## 第11-12讲 数据建模思想与方法

### 抽象层次

#### 模型与元模型

**元模型**：对模型的抽象，由一组**抽象概念**及其之间关系构成。

**模型**：依据元模型中的抽象概念及关系对现实世界进行理解，获得**具体概念**及其具体关系而构成。

#### 数据模型与概念模型

**数据模型**：表达计算机世界的模型。如关系模型、网状模型、层次模型。

**概念模型**：表达信息世界的模型。如E-R模型。

### E-R模型

基本概念：

- **实体**：客观存在并可相互区分的事物，具有“类”和“个体”的概念，分别称为“实体”与“实例”。

- **属性**：实体具有的某一方面特性。实体具有属性（对应于列名），实例也具有属性（对应于列值）。

  属性的分类方式：

  - **单一属性**与**复合属性**
  - **单值属性**与**多值属性**
  - **可空值属性**与**非空值属性**
  - **原始属性**与**导出属性**（由其他属性计算而得）

- **联系**：一个实体的实例和其他实体实例之间可能发生的联系。

  **度（元）**：参与联系的实体（不是实例）数目。

  **角色**：实体在联系中的作用。当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需显式指明其角色。

  **基数**：一个实体的实例通过一个联系能与另一实体中实例相关联的数目。

  联系的分类方式：

  - 二元联系分类：**一对一联系**、**一对多联系**、**多对多联系**（此处“一”“多”指实例数目）
  - 联系端点分类：**完全参与联系**（该端实例最小基数为1）、**部分参与联系**（该端实例最小基数为0）

  实体是相对稳定的，但联系是多样化的。

- **关键字（码）**：实体中能用其值唯一区分开每一实例的属性或属性组合。

#### 图示方法

- Chen方法

  实体：矩形

  属性：椭圆

  - 多值属性：双线椭圆
  - 导出属性：虚线椭圆
  - 复合属性：属性与子属性间连线

  关键字：属性名加下划线

  - 复合关键字：下划线下标出相同数字
  - 多组关键字：下划线下标出不同数字

  联系：菱形

  属性属于某一实体/联系：直线连接

  联系连接某些实体：直线连接

  - 区分一对一、一对多、多对多联系：
    - 实体基数为1：有箭头，箭头指向实体
    - 实体基数大于1：无箭头
  - 区分部分参与联系、完全参与联系：
    - 部分参与联系：单直线（**即基数范围为0\~n**）
    - 完全参与联系：双直线
  - 上述两种区分也可通过在联系直线旁标注基数/基数范围进行区分。最大基数不确定时可简记为m或n。
  - 角色：连接直线上标记角色名

- Crow's Foot方法

  实体：分为上下两格的矩形框，实体名称在上格中

  属性：实体框的下格中

  关键字：属性名加下划线

  联系：菱形；或省略边框，直接以联系名表示

  - 区分基数：
    - 基数范围一端为0的，在**直线内**写0
    - 基数范围一端为1的，在**直线内**写1
    - 基数可大于1的，直线另一端为爪形

  其余未说明特性与Chen方法相同。

- IDEF1X方法（工程化方法）

  - 概念：

    实体分为**独立实体**与**从属实体**。

    - **独立实体**（强实体）：其关键字与它和其它实体的联系无关（不从其它实体继承属性用作关键字）。即**主键中不含外键**。
    - **从属实体**（弱实体）：其关键字的一部分（或全部）属性是从其它实体主关键字继承而来。即**主键中包含外键**。

    作用名：实体中的外键在该实体中的重新命名。

    联系的分类：

    - **连接联系**（父子联系、依存联系）：一对多的联系，一端称为父实体，多端称为子实体。
      - **标定联系**：从属实体与其父实体间的联系，子实体主键中包含来自父实体的外键。
      - **非标定联系**：两个不具有从属关系的实体间的联系，子实体非主键中包含来自父实体的外键。
    - **非确定联系**：多对多的联系，需要引入相交实体拆分为一对多联系进行表达。
    - **分类联系**：联系一般实体与多个分类实体的联系。分类实体具有与一般实体相同的主键，但各自可能有更多的属性。**至少有一个分类实体需要有更多的属性。**
      - **完全分类联系**：各个分类实体实例集的并集恰好为一般实体实例集。
      - **非完全分类联系**：各个分类实体实例集的并集小于一般实体实例集。

    具体化/泛化：

    - 具体化：在实体的实例集中，根据一些实例与其它实例不同的特性，对实例集进行划分。

    - 泛化：若干个实体根据共有的性质，合成一个较高层的实体。与具体化互逆。

      具体化与泛化在E-R图中以**标记为ISA的三角形**表示。

  - 规则：

    - 相同的含义总是使用同一名称，不同含义总是使用不同名称。（实体名、属性名、作用名）
    - 单主规则：实体可以具有任意个属性，一个属性只能归属于一个实体。
    - 非空规则：每一个实例的每一个属性必须具有一个值。
    - 非重复规则：实例的每一个属性仅能具有一个值。
    - 最小关键字规则：任意一组关键字中任意去除一个属性，都无法唯一确定实例。
    - 完全函数依赖规则：当主键不仅一个属性时，非键属性值须完全函数依赖于主键。即若仅确定一部分主键，无法唯一确定非键属性值。
    - 非传递依赖规则：非键属性不能由其它非键属性值确定。

  - 图示：

    实体：分为上下两格的矩形框，实体名及实体号在框上方，主键在上格，次键及其它属性在下格。外键后标有“(FK)”字样，次键后标有“(AK n)”字样，不同组的次键以标号n不同进行区分。若外键有重命名，则写作“作用名.继承属性名(FK)”。

    - 独立实体：方角矩形框
    - 从属实体：圆角矩形框

    联系：直线

    - 连接联系：子实体端以圆圈为端点，可标注基数为P（大于0）/Z（0或1）/具体数/省略（非负）。联系名标注于直线旁。
      - 标定联系：直线为实线
      - 非标定联系：直线为虚线
    - 分类联系：由一般实体端发出直线，以圆圈结尾。圆圈对端有单/双短线垂直于原直线，短线上发出若干直线到达各分类实体。用于分类的属性名（称鉴别器属性）标注于短线旁。**分类实体的主关键字可不标识**。
      - 完全分类联系：双短线
      - 非完全分类联系：单短线

## 第13讲 数据库设计过程

### 需求分析

- 了解部分-岗位划分。
- 收集每一岗位的“源”（报表、单据、查询需求、管理需求等），形成源表。
- 理解每一“源”，包括源的属性构成、处理规则、属性处理规则等。
- 提交需求分析报告。

### 概念数据库设计

- 识别实体与联系。
- 绘制E-R图或IDEF1X图，表达业务规则。
- 定义实体、联系及实体的属性构成。
- 提交概念数据库设计报告

### 逻辑数据库设计

- 概念图转换为关系模型。
- 检查逻辑数据库设计正确性。
- 定义全局模式和外模式。
- 提交逻辑数据库设计报告。

#### 概念图转关系模式

E-R图：

- 实体、属性、关键字分别直接转换为关系、属性、关键字。
- 对于复合属性，可将各个分量作为单独的属性，也可将整个复合属性作为一个属性。
- 对于多值属性，将该属性与实体关键字组成一个新的关系。
- 对于一对一联系：
  - 联系有一方全部参与时，将另一方关键字作为全部参与一方关系的属性。
  - 联系双方均部分参与时，将联系定义为一个新的关系，属性为双方关键字。
- 对于一对多联系，将单方参与实体的关键字作为多方参与实体的属性。
- 对于多对多联系，将联系定义为新的关系，属性为双方实体关键字。
- 对于多元联系，可继承参与联系的各个实体的关键字形成新的关系，可选择新增一个区分属性（如序号）。多元联系也可转化为多个二元联系。
- 泛化实体与具体化实体转为不同的关系，低层实体的关系包含高层实体的关键字。但若泛化实体被完全分类，则泛化实体可以不转为关系，由低层实体的关系包括上层所有属性。

IDEF1X图：

- 仅需将实体转换为关系，无需处理联系。
- 其余参照E-R图处理方式即可。

#### 不正确数据库的可能问题

- 非受控冗余问题：数据存在冗余（某些数据联系反复出现）时，若修改数据，所有冗余数据需同步更新。
- 插入异常：插入不全确定的记录时，数据含义变得不明。
- 删除异常：某些信息仅依靠与其关联的记录存储时，若这些记录全部被删除，则这些信息将随之丢失。

#### 数据库设计理论

- 数据依赖理论
- 关系范式理论
- 模式分解理论

### 物理数据库设计

- 利用具体DBMS创建数据库/表。
- 使用与具体DBMS相关的理论知识确定物理存储方式与存储空间。
- 创建索引、视图等。
- 提交物理数据库设计报告。

## 第14讲 函数依赖

**函数依赖**：在某一关系模式$R(U)$中，对于属性（集）$X$和$Y$，称“$X$函数决定$Y$”或“$Y$函数依赖于$X$”，当且仅当对$R(U)$的任意关系$r$，不存在$r$中的两个元组其$X$属性值相等而$Y$属性值不等。即在该关系模式下任意可能元组中，一旦确定$X$的值即可确定$Y$的值。记作$X\rightarrow Y$。

- **非平凡的函数依赖**：称$X\rightarrow Y$为非平凡的，当且仅当属性集$Y\not \subset X$。
- 完全/部分函数依赖：
  - **完全函数依赖**：对属性集$X$与$Y$，称$X\rightarrow Y$为完全函数依赖，当且仅当$X$的任意真子集$X'$均不满足$X'\rightarrow Y$。记作$X\xrightarrow{f}{} Y$。
  - **部分函数依赖**：称$X\rightarrow Y$为部分函数依赖，当且仅当其不为完全函数依赖。记作$X\xrightarrow {p}{} Y$。
- **传递函数依赖**：称$X\rightarrow Z$为传递函数依赖，当且仅当存在$Y$，使得$X\rightarrow Y$，$Y\rightarrow Z$，$Y\not \rightarrow X$，且前述3个函数依赖均为非平凡的。

函数依赖也可以基于具体关系，而不基于某一关系模式。即其对于属于同一关系模式的另一关系可能不成立。

**候选键**：对关系模式$R(U)$，称属性（集）$K$为候选键，当且仅当$K\xrightarrow{f}{}U$。

**超键**：称$S$为超键，当且仅当存在候选键$K$，$S\supset K$。

**主属性**：包含在**任一候选键**（而不一定是主键）中的属性。

**外来键（外键）**：对关系模式$R$中的属性（集）$X$，称$X$为外来键，当且仅当$X$并非$R$的候选键，但却是另一关系的候选键。

**逻辑蕴涵**：对函数依赖集$F$，称$F$逻辑蕴涵$X\rightarrow Y$，当且仅当以形式逻辑推理的方式从$F$中的函数依赖可推出$X\rightarrow Y$。记作$F\models X\rightarrow Y$。

**闭包**：被$F$逻辑蕴涵的所有函数依赖构成的集合称作$F$的闭包，记作$F^+$。

- **全函数依赖族（函数依赖完备集）**：称$F$为全函数依赖族，当且仅当$F^+=F$。

**属性（集）闭包**：对于属性（集）$X$，称$\{属性Y|F\models X\rightarrow Y\}$为$X$关于$F$的属性（集）闭包，记作$X^+_F$。

**覆盖**：称$F$覆盖$G$，或$G$覆盖$F$，当且仅当$F^+=G^+$。此时也称$F$和$G$是等价的。

- **最小覆盖**：称$F$为最小覆盖，若
  - $F$中每个函数依赖右部均为单个属性。
  - 去掉$F$中任意一个函数依赖所得$F'$均不等价于$F$。
  - 去掉$F$中任意一个函数依赖左端部分属性所得$F'$均不等价于$F$。

### Armstrong公理

设$R(U,F)$为属性集$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，具有函数依赖$F$。则有如下公理：

- A1（自反律）：若$Y\subset X\subset U$，则$F\models X\rightarrow Y$。
- A2（增广律）：若$X\rightarrow Y\in F$，$Z\subset U$，则$F\models XZ\rightarrow YZ$。
- A3（传递律）：若$X\rightarrow Y\in F$，$Y\rightarrow Z$，则$F\models X\rightarrow Z$。

#### 推论

- 合并律：若$X\rightarrow Y$，$X\rightarrow Z$，则$X\rightarrow YZ$。
- 伪传递律：若$X\rightarrow Y$且$WY\rightarrow Z$，则$XW\rightarrow Z$。
- 分解律：若$X\rightarrow Y$，$Z\subset Y$，则$X\rightarrow Z$。
- 重要引理：$X\rightarrow A_1,A_2,\dots,A_n \Leftrightarrow X\rightarrow A_i(1\leq i \leq n)$

## 第15讲 关系范式

**多值依赖**：对于$X$给定值，$Y$有一组值与之对应，且在确定该$X$值时，对该组$Y$值中的任一个值，与其对应的元组集在$U-X-Y$上的投影均相同。记作$X\rightarrow \rightarrow Y$。其中$X$与$Y$可以相交。函数依赖是多值依赖的特例。

- 互补多值依赖：指$X\rightarrow \rightarrow Y$与$X\rightarrow \rightarrow U-X-Y$这一对依赖。

以下范式条件逐渐加强（上为下的必要条件）（除W4NF）。

**第1范式（1NF）**：关系的每个分量都是不可分的数据项。

**第2范式（2NF）**：关系满足1NF，且每一非主属性完全函数依赖于候选键。

**第3范式（3NF）**：关系满足2NF，且不含传递函数依赖。

**Boyce-Codd范式（BCNF）**：关系满足1NF，且每一非平凡函数依赖左端必含有候选键。

- 转换为BCNF：将函数依赖左端不含候选键的依赖单独组成一个关系。

**第4范式（4NF）**：关系满足1NF，且每一非平凡依赖（函数依赖、多值依赖）左端必含有候选键。

- **弱第4范式（W4NF）**：关系满足3NF，且每一对互补多值依赖中必有一个为函数依赖。

通常的数据库设计满足BCNF即可。

## 第16讲 模式分解

**模式分解**：关系模式$R(U)$的分解指使用一组新的关系模式$\rho=\{R_1(U_1),R_2(U_2),\dots,R_k(U_k)\}$代替之。其中$U=\bigcup_{i=1}^kU_i$，且$\forall i\neq j,U_i\not \subset U_j$。此时为简便起见，可使用$R_i$指代$R_i(U_i)$。

**投影连接**：对关系模式$R$的关系$r$，定义其向$\rho$的投影连接为$m_\rho(r)=\mathop \Join_{i=1}^k\pi_{R_{i}}(r)$。其具有性质：

- $r\subset m_\rho(r)$
- $\pi_{R_i}(m_\rho(r))=\pi_{R_i}(r)$
- $m_\rho(m_\rho(r))=m_\rho(r)$

### 模式分解类别

- **无损连接分解**：对关系模式$R(U,F)$，称$\rho$为$R$相对于$F$的一个无损连接分解，当且仅当对任意满足$F$的$r$，$m_\rho(r)= r$。

  - 检验算法：

    - 一般情形：

      1. 构造$R_\rho$矩阵：第$i$行行标$R_i$，第$j$列列标$A_j$。
         $$
         R_\rho[i,j]=
         \left\{
         \begin{array}{lr}
         	a_j,&A_j\in R_i\\
         	b_{ij},&A_j\notin R_i
         \end{array}
         \right.
         $$

      2. 反复执行本步，直至$R_\rho$无法被修改：任取一函数依赖$X\rightarrow Y$（不失一般性，设$Y$为单列），选出$X$中各列内容对应相同的行集$L$（即$\forall x\in X,\forall l_1,l_2\in L,l_1[x]=l_2[x]$），若$\exists l\in L,\exists j,l[Y]=a_j$，则修改$L$中所有行的$Y$列为上述$a_j$。

      3. 若$R_\rho$中有一行的所有元素均出现$a$，则该分解为无损连接分解；否则为有损连接分解。

    - 二元分解情形：设$\rho=\{R_1,R_2\}$，则其为无损连接分解当且仅当$R_1\cap R_2\rightarrow R_1-R_2$或$R_1\cap R_2\rightarrow R_2-R_1$。

  - 性质：

    - 将无损连接分解中的某一子模式继续进行无损连接分解，则整体仍是无损连接分解。
    - 向无损连接分解中加入子模式，则整体仍是无损连接分解。

- **保持依赖分解**：对关系模式$R(U,F)$，称$\rho$为$R$相对于$F$的一个保持依赖分解，当且仅当$\forall f\in F,(\mathop \bigcup_{i=1}^k \pi_{R_i}(F))\models f$，其中$\pi_{R_i}(F)=\{X\rightarrow Y\in F|X,Y\in R_i\}$。

  - 检验算法：
    - 一般情形：
      1. 反复执行本步，遍历$F$中所有函数依赖$X\rightarrow Y$：求属性闭包$X^+_G$，若$Y \notin X^+_G$则该分解不为保持依赖分解。
      2. 若上一步中未发现不满足条件者，则该分解为保持依赖分解。

无损连接分解与保持依赖分解**互不为**充分条件。

### 模式分解算法

- 无损连接地分解为BCNF或4NF：
  1. 反复执行本步，直至所有子模式均满足BCNF或4NF：寻找一不满足BCNF或4NF的子模式$s$，其中必存在$X\rightarrow A$且$X$并非超键。此时将$s$分解为$s_1(X,A)$及$s_2(s-\{A\})$。
- 保持依赖地分解为3NF：
  1. 将不存在于函数依赖中的属性单独组成一模式。
  2. 反复执行本步，直至不存在$X$使得$\{X\rightarrow A_1,X\rightarrow A_2,\dots,X\rightarrow A_m\}\subset F$：将子模式$s(X,A_1,A_2,\dots,A_m)$加入子模式集，同时从$F$中删去上述函数依赖。
- 无损连接且保持依赖地分解为3NF：
  1. 保持依赖地分解为3NF，得分解$\sigma$。
  2. 若分解中有一关系包含候选键$X$，则$\sigma$即为所求；否则$\sigma\cup\{X\}$即为所求。

### 连接依赖与第五范式

**连接依赖**：对关系模式$R$，其上分解$\rho=\{R_1,R_2,\dots,R_n\}$，若对$R$上任意关系$r$均有$r=m_\rho(r)$，则称$R$的属性集满足连接依赖，记作${\rm JD}[R_1,\dots,R_n]$。多值依赖是连接依赖的特例。

**第5范式（5NF）**：关系的每个连接依赖均按其候选键进行连接运算。5NF$\subset$4NF。

## 第17讲 数据库物理存储

数据组织的基础：存储体系

读一个磁盘块用时：$最短时间=传输时间$，$最长时间=寻道时间+旋转时间+传输时间$。

记录存储方式分类：

- 定长记录（以长度区分记录），变长记录（以指针或标志区分记录）。
- 非跨块存储（磁盘块剩余小空间直接浪费，可并行查询），跨块存储（磁盘块剩余小空间存储一条记录的一部分，不可并行查询）。

表所占磁盘块的分配方法：

- 连续分配：分配至连续磁盘块上。缺点：扩展困难。
- 链接分配：每个数据块中包含指向下一数据块的指针。缺点：访问速度慢。
- 按簇分配：簇为若干连续磁盘块，不同簇之间以指针连接。
- 索引分配：索引块中存放指向实际数据块的指针。

### RAID技术

#### 特点

- **并行处理**：并行读取多个磁盘，数据拆分存储于不同磁盘上，分为**比特级拆分**与**块级拆分**
- **可靠性**：校验与纠错。校验方法有扇区/块读写校验与磁盘间读写校验。

#### 类别

- RAID0：块级拆分，但无冗余。
- RAID1：每一磁盘块有一镜像磁盘块。
- RAID2（位交叉纠错）：4个存储位（位于4个存储盘）+3个校验位（位于3个校验盘）
- RAID3（位交叉校验）：4个存储位（位于4个存储盘）+1个校验位（位于校验盘）。借助扇区校验判断出错盘，依据校验盘纠错。是RAID2的改进。
- RAID4（块交叉校验）：使用块拆分，其余与RAID3相似。
- RAID5（块交叉分布式校验）：使用块拆分，互为校验盘，避免固定校验盘磨损过大。

### 文件组织方法

- 无序记录文件（堆文件）：新记录插入至文件尾部或被删除记录处，删除记录时仅需做删除标记。

  特点：更新效率高，检索效率低。

  改进：

  - 数据库重组：移走已删除记录以回收空间。

- 有序记录文件（排序文件）：按某属性（组）的值的顺序插入。

  排序字段：用于存储排序的属性，一般使用主码，又称排序码。

  特点：检索效率高，更新效率低。按非排序字段检索时效率不会提高。

  改进：

  - 溢出文件：临时的无序文件，用于保存新增记录。
  - 数据库重组：将溢出文件合并至主文件中。

- 散列文件：依据散列函数对记录的某属性（组）的值计算，得到其应存放的位置。使用链接法处理桶满情形（每个桶链接至一个溢出桶）。

  散列字段：用于进行散列函数计算的属性，一般使用主码，又称散列码。

  特点：检索效率与更新效率均较高。

- 聚簇文件：将具有相同或相似属性值的记录存放于连续磁盘簇块中。

  多表聚簇：将若干相互关联的表存储于一个文件中。

  特点：某些情况下效率较高。

### Oracle物理存储

#### 逻辑存储层

- 数据库分为若干表空间，数据库存储容量即各个表空间存储容量的组合。
- 表空间由若干文件构成，但数据可跨文件操作。
- 文件中存储若干表，但一个表也可能存储于多个文件中。

#### 物理存储层

- 段是一组分配了特定数据结构的盘区。段中可存储若干表（如聚簇文件），表也可以分布于若干段。
- 盘区是特定数量的连续数据块，其数量可动态变更。
- 数据块是最小存储单位，又称页，相当于扇区。

## 第18讲 数据库索引技术

### 基本概念

**索引**：定义在存储表基础之上，有助于无须检查所有记录而快速定位所需记录的**辅助存储结构**。由**索引项**构成。

**索引项**：由**索引字段**与**行指针**构成。

- **索引字段**：由表中某些列（通常为1列）的值串接而成，索引中**通常**存储索引字段的每一个值。
- **行指针**：指向表中包含对应索引字段值的记录在磁盘上的存储位置。

存储索引项的文件称为**索引文件**，存储表的文件称为**主文件**。索引文件不改变存储表的物理存储结构，但其能提高存储表的访问速度。但同时，更新操作必须同步更新索引文件与主文件。

索引文件组织方法：

- 排序索引文件：按索引字段值的某种顺序存储。
- 散列索引文件：按索引字段值使用散列函数分配散列桶进行存储。

性能衡量标准：访问时间、插入时间、删除时间、空间负载、支持存取的有效性（支持何种类型查询）。

### SQL语言中的索引

在DBMS中，若为表定义了主键，则DBMS将自动创建主索引。DBMS也将自动在更新表时维护所有索引。

- create \[Unique\] index 索引名 on 表名(列名 \[asc|desc\]\[\[, 列名\[asc|desc\]\] ...\]);

  为指定表的指定字段创建索引。

  Unique：索引字段的值在索引文件中是否允许重复。

- drop index 索引名;

  撤销指定索引。

### 稠密索引与稀疏索引

稠密索引：对索引字段每一个值，都有一个索引项与之对应，指向其位置。使用稠密索引检索时，可先查询索引项，然后依据索引读主文件。

- 候选键的稠密索引：直接建立一对一索引即可。
- 非候选键的稠密索引：
  - 索引字段不可重复，主文件按索引字段排序：索引项指向主文件中对应索引字段值的第一条记录。
  - 索引字段可重复，主文件不按索引字段排序：主文件中每一条记录都有对应的索引项。
  - 索引字段不可重复，主文件不按索引字段排序：引入中间层（指针桶）解决对应问题。

稀疏索引：仅对索引字段的部分值，有索引项与之对应。要求主文件必须按对应索引字段属性排序存储。使用稀疏索引检索时，首先寻找小于指定索引值的最大索引项，然后对主文件顺序检索。

### 主索引与辅助索引

锚记录（块锚）：存储块的第一条记录。

主索引：对每一存储块有一对应索引项，索引项的索引字段值为块锚的索引字段值。主索引通常建立在有序主文件基于主码的排序字段上。

辅助索引：定义在主文件的一个或多个非排序字段上的辅助存储结构。辅助索引是稠密索引，通常采用中间层（指针桶）解决查询问题。

一个主文件至多有一个主索引，但可以有多个辅助索引。主索引通常建立于主码或排序码上。

### 其它类型索引

聚簇索引与非聚簇索引：在主文件中邻近存储的记录在索引中也邻近存储，称为聚簇索引，否则称为非聚簇索引。聚簇索引通常定义于聚簇字段上，其中聚簇字段指非主码的排序字段。主索引通常是聚簇索引。主索引或聚簇索引能够决定记录存储的位置（决定插入、删除等更新操作）。

倒排索引：由关键字指向若干存在该关键字的文档的索引，使用中间层（指针桶）管理。

多级索引：对索引再建立索引。如B树/B+树索引。

### B+树/B树索引

#### B+树索引

每个节点结构为$(P_1,K_1,P_2,K_2,\dots,K_{n-1},P_n)$，其中$P$为指向存储块数据块或记录的指针，$K$为索引字段值，在节点中有序排列（在索引字段可重复时，节点中的$K$可重复）。指针指向的字段值范围由其两端的$K$值左闭右开决定。

对叶节点而言，$P_1$至$P_{n-1}$指向数据块或数据记录，$P_n$指向按顺序的下一个叶节点。

根节点至少有2个指针被使用；非根节点至少有一半指针被使用。

**插入操作**：从根至下搜索待插入位置，然后从底至上插入并进行节点分裂，直至所更新节点无需分裂为止。分裂时首先取出中间键，然后将其余键均分（多者归左节点）。每次分裂，父节点中将增加一个索引字段值，其恰好为分裂节点多出的中间键。

**删除操作**：从根至下搜索待删除记录，然后从底至上删除并进行节点合并（**“合并”概念可指节点记录转移或两节点合并为一节点**）：当节点内有效指针过少时，首先检查兄弟节点是否有可转移来的指针，若有则转移并修改共同父节点的记录后结束；否则与兄弟节点进行合并，并删除共同父节点中指向上述右兄弟节点的指针，然后递归对共同父节点做记录删除处理。当根节点有效指针少于2个时，删除根节点，并将根指针指向根节点唯一的子节点。

#### B树索引

每个索引字段值在整棵树中仅出现一次，非叶节点中的指针也可以指向主文件。非叶节点中有n个键值及2(n+1)个指针。

### 散列索引

使用散列表思想，将键值映射至桶。当主桶（默认桶）被充满时，使用链表结构在主桶后建立溢出桶。

静态散列索引：桶数目不变。

动态散列索引：桶数目随键值数增多而动态增加。

- 可扩展散列索引：使用散列值的**前若干位**进行索引。维护桶指针数组将散列值前缀映射至桶，每一桶又记录一整数表示自身使用几位前缀。当需要分裂桶时，仅分裂需要分裂的桶（重新散列）并扩张指针数组。扩张指针数组后可能有多个指针指向一个不需分裂的桶。
- 线性散列索引：使用散列值的**后若干位**进行索引。维护桶指针数组将散列值后缀映射至桶。每个桶都允许有若干溢出桶，但散列表要求记录数满足与桶数的某种小于关系。当小于关系满足时，以静态方式使用散列表；当插入记录使小于关系不满足时，选择一个合适的桶增加后缀位进行分裂，使得桶指针数组仅扩张1个元素指向新桶，之后重新散列该桶记录即可。

## 第19-20讲 数据库查询实现算法

查询实现的两种策略：

- 物化计算策略：每个关系操作扫描一遍数据库，产生一个完整的中间关系或结果关系。
- 流水线计算策略：一组关系操作扫描一遍数据库，产生不完整的中间关系或一个完整的结果关系。

### 一趟扫描算法

**表空间扫描算法**：对聚簇关系，依次读取每一个磁盘块（但不排序），复杂度为$B_R$。对非聚簇关系，依次读取每一条记录，复杂度为$T_R$。

**索引扫描算法**：对聚簇关系，依据索引扫描每一个磁盘块（但不排序），复杂度为$B_R$。对非聚簇关系，依次读取每一条记录，复杂度为$T_R$。

记号：

$T_R$（T_R）：关系$R$的元组数目

$B_R$（B_R）：关系$R$的磁盘块数目

$M$（M）：主存缓冲区的页数（每页容量等于一个磁盘块容量）

$I_R$（I_R）：关系$R$每个元组的字节数

$b$（b）：每个磁盘块的字节数

- 连接操作：$R\mathop \Join \limits_{R.A \space \theta \space S.B} S$

  结果关系磁盘块数量：$B_{R\times S}=\dfrac{T_RT_S(I_R+I_S)}{b}$

  - 基本实现

    应用条件：3个内存页（装入$R$页，装入$S$页，输出页）

    算法复杂度（仅考虑I/O，忽略保存结果I/O）：$B_R+B_R\times B_S$

    ```cpp
    for(i = 1; i <= B_R; i++) {
        read_n_th_block_of(i, R);
        for(j = 1; j <= B_S; j++) {
            read_n_th_block_of(j, S);
            for(p = 1; p <= b / I_R; p++) {
                read_n_th_record_of(p, R);
                for(q = 1; q <= b / I_S; q++) {
                    read_n_th_record_of(q, S);
                    if(theta(R[p].A, S[q].B))
                        join_and_add_to_result(R[p], S[q]);
                }
            }
        }
    }
    ```

  - 全主存实现

    应用条件：主存可容下两个关系

    算法复杂度：$B_R+B_S$

    ```cpp
    for(i = 1; i <= B_R; i++)
        read_n_th_block_of(i, R);
    for(j = 1; j <= B_S; j++)
        read_n_th_block_of(j, S);
    for(p = 1; p <= T_R; p++) {
        read_n_th_record_of(p, R);
        for(q = 1; q <= T_S; q++) {
            read_n_th_record_of(q, S);
            if(theta(R[p].A, S[q].B))
                join_and_add_to_result(R[p], S[q]);
        }
    }
    ```

  - 半主存实现

    应用条件：主存仅能容下一个关系（$B_S\ge B_R,B_R<M<B_R+B_S$）

    算法复杂度：$B_R+B_S$

    ```cpp
    for(i = 1; i <= B_R; i++)
        read_n_th_block_of(i, R);
    for(j = 1; j <= B_S; j++)
        read_n_th_block_of(j, S);
    	for(p = 1; p <= T_R; p++) {
        	read_n_th_record_of(p, R);
        	for(q = 1; q <= b / I_S; q++) {
            	read_n_th_record_of(q, S);
            	if(theta(R[p].A, S[q].B))
                	join_and_add_to_result(R[p], S[q]);
            }
        }
    }
    ```

  - 大关系实现

    应用条件：主存无法容下任何一个关系（$B_S\ge M,B_R\ge M$） 

    算法复杂度：$\dfrac{B_RB_S}{M-2}+B_S$

    ```cpp
    for(i = 1; i <= B_S / (M - 2); i++) {
        read_n_th_subset_of(i, S); // 将R_S分为M-2个子集，每轮循环使用其中一个子集
        for(j = 1; j <= B_R; j++) {
            read_n_th_block_of(j, R);
            for(p = 1; p <= (M - 2) * b / I_S; p++) {
                read_n_th_record_of(p, S);
                for(q = 1; q <= b / I_R; q++) {
                    read_n_th_record_of(q, R);
                    if(theta(R[p].A, S[q].B))
                        join_and_add_to_result(R[p], S[q]);
                }
            }
        }
    }
    ```

  - 迭代器实现

    ```cpp
    void open() {
        R.open();
        S.open();
        r = R.getNext();
    }
    
    tuple getNext() {
        do {
            s = S.getNext();
            if(s == NULL) {
                S.close();
                r = R.getNext();
                if(r == NULL)
                    return NULL;
                else {
                    S.open();
                    s = S.getNext();
                }
            }
        } while(isJoinable(r, s));
        return join(r, s);
    }
    
    void close() {
        R.close();
        S.close();
    }
    ```

  - Zig-Zag实现

    应用条件：连接条件为$R.Y=S.Y$，两关系在$Y$上均有有序索引

    ```cpp
    i = R.begin(); // R在Y上索引的迭代器
    j = S.begin(); // S在Y上索引的迭代器
    while(i != R.end() && j != S.end()) {
        if(i->Y < j->Y)
            i++;
        else if(i->Y > j->Y)
            j++;
        else {
            for(k = i; k != R.end() && k->Y == i->Y; k++) {
                i = k;
                for(l = j; l != S.end() && l->Y == j->Y; l++) {
                    j = l;
                    join_and_add_to_result(*k, *l);
                }
            }
            i++;
            j++;
        }
    }
    ```

- 并操作（无去重）

  实现：使用迭代器实现即可。

- 去重操作

  应用条件：主存可容下整个关系

  实现：迭代每个元组，在主存中维护数据结构检查其是否出现过即可。

- 分组聚集操作

  应用条件：主存可容下所有分组的聚集信息

  实现：迭代每个元组，在主存中维护数据结构（例如散列表）更新聚集信息即可。但**注意有些分组聚集操作仅能在全部数据均读入后才可进行**。

- 集合操作（下标为S）（需去重）及包操作（下标为B）（无需去重）

  应用条件：主存可容下完整的较小关系

  实现：先扫描较小关系再扫描较大关系，在主存中维护数据结构进行集合操作去重或包操作计数即可。

**注意：在包与集合的操作、去重操作、分组聚集操作、排序操作中，仅包上的并操作在任何时候均可一趟扫描实现。**

### 两趟扫描算法

思路：第一趟扫描将原集合划分为具有特殊性质的子集合；第二趟扫描通过子集处理全局性信息。

基于排序的两趟算法要点：原集合上的操作能否等价于在横向处理后的子集上做纵向归并的结果。

基于散列的两趟算法要点：原集合上的操作能否等价于子集上操作的并集。

- 两阶段多路归并排序算法

  概念：

  - 内排序：待排序数据完全装入内存，在内存中完成排序。
  - 外排序：待排序数据不能完全装入内存，需要分批装入内存处理。

  实现：

  - 首先将待排序数据分为子集，要求每个子集可单独完整装入内存，子集数量不超过内存块数量。

  - 第一趟：对每个子集进行内排序。
- 第二趟：对每个子集在内存中设置一个输入缓冲区；此外在内存中总共设置一个输出缓冲区，进行归并排序。
  
  在待排序集合更大的情况下，可以采取多趟扫描算法。

- 散列算法

  实现：

  - 选择两个散列函数$h_p$与$h_r$。
  - 第一趟：使用$h_p$将原始关系划分为若干子表。
  - 第二趟：分别将每个子表使用$h_r$读入内存并处理。

- 去重操作

  - 基于排序

    复杂度：$3B_R$（不考虑输出），$4B_R$（考虑输出）

    - 第一趟：划分子表并进行多路归并排序。
    - 第二趟：在排序的归并阶段，若发现当前待输出记录与前一个相同，则直接不输出，进而完成去重。

  - 基于散列

    复杂度：$3B_R$（不考虑输出），$4B_R$（考虑输出）

    - 第一趟：使用$h_p$划分子表并存储。
    - 第二趟：对每一子表，使用$h_r$进行散列并去重。

- 分组聚集操作

  - 基于排序

    复杂度：$3B_R$（不考虑输出），$4B_R$（考虑输出）

    - 第一趟：划分子表并进行多路归并排序。
    - 第二趟：在排序的归并阶段，若发现当前待输出记录的分组依据字段值与前一个相同，则进行分组聚-集计算，否则作为新分组输出。

  - 基于散列

    复杂度：$3B_R$（不考虑输出），$4B_R$（考虑输出）

    - 第一趟：依据分组属性设计$h_p$，使分组属性相同的记录被散列至同一子表中。使用$h_p$划分子表并存储。
    - 第二趟：依据分组属性设计另一$h_r$，对每一子表，使用$h_r$进行散列，并进行相应聚集操作。

- 集合操作及包操作

  - 基于排序
    - 包并：无需两趟扫描，直接合并即可。
    - 集合并：对两集合数据一同使用归并排序进行去重即可。
    - 包交：对两包一同使用归并排序，归并时统计相同元素在两集合中的较小出现次数。
    - 集合交：对两集合一同使用归并排序，仅输出归并时同时出现在两集合中的元素。
    - 包差：对两包一同使用归并排序，归并时输出相同元素在两集合中出现次数的差。
    - 集合差：对两集合一同使用归并排序，仅输出归并时仅出现在左侧集合中的元素。
  - 基于散列：
    - 包并：无需两趟扫描，直接合并即可。
    - 集合并：第一趟使用$h_p$分别将两集合散列为子表；第二趟每次将其中一个子表完全读入内存，然后遍历另一个集合的相同散列值子表，使用$h_r$散列去重。
    - 其余操作类似处理。

- 连接操作

  - 基于排序
    - 第一趟：划分子表并对连接条件（条件须为相等）属性进行多路归并排序。
    - 第二趟：归并时对满足连接条件的两集合所有元组进行连接并输出。
  - 基于散列
    - 第一趟：依据连接条件（条件须为相等）属性设计$h_p$，使用$h_p$分别将两集合散列为子表。
    - 第二趟：每次将其中一个子表完全读入内存，然后遍历另一个集合的相同散列值子表，使用$h_r$散列寻找可连接记录并进行连接。

## 第21讲 数据库查询优化技术

三个层面：语义优化，语法（逻辑）优化，执行（物理）优化。

### 逻辑优化

原理：基于关系代数，优化操作次序。

策略：

- 尽可能早地做选择与投影
- 选择与投影尽量串联以便只进行一次扫描
- 将投影与二元运算结合
- 将选择与笛卡尔积合并为连接操作
- 连接前对关系预处理（临时索引、排序等）
- 求公共子表达式

**关系代数操作等价变换定理**：

- **连接**、**笛卡尔积**、**并**、**交**分别具有**交换律**。
- **连接**、**笛卡尔积**、**并**、**交**分别具有**结合律**。
- **投影串接律**：若$A\subset B$，则$\pi_A(\pi_B(E))=\pi_A(E)$。注意该等式可双向使用。
- **选择串接律**：$\sigma_{F_1}(\sigma_{F_2}(E))=\sigma_{F_1\and F_2}(E)$。注意该等式可双向使用。
- **选择投影交换律**：若条件$F$只涉及到属性集$A$中的属性，则$\pi_{A}(\sigma_{F}(E))=\sigma_{F}(\pi_A(E))$。更一般地，设选择条件$F$涉及到的属性集为$B$，且$B\not \subset A$，则$\pi_{A}(\sigma_{F}(E))=\pi_{A}(\sigma_{F}(\pi_{A\cup B}(E)))$。
- **选择乘积交换律**：若条件$F$只涉及到$E_1$中的属性，则$\sigma_F(E_1\times E_2)=\sigma_F(E_1)\times E_2$。
- **投影乘积交换律**：设属性集$A\subset E_1$，属性集$B\subset E_2$，则$\pi_{A\cup B}(E_1\times E_2)=\pi_A(E_1)\times \pi_B(E_2)$。
- **选择集并交换律**：$\sigma_F(E_1\cup E_2)=\sigma_F(E_1)\cup \sigma_F(E_2)$。
- **选择集差交换律**：$\sigma_F(E_1-E_2)=\sigma_F(E_1)-\sigma_F(E_2)$。
- **投影集并交换律**：$\pi_A(E_1\cup E_2)=\pi_A(E_1)\cup \pi_A(E_2)$。
- 注意**不存在投影集差交换律**。

算法：

1. 将选择拆为若干单条件串联选择，并尽可能下移。
2. 将投影尽可能下移（包括创建可能减少属性数目的投影并下移），并且消除所有无用投影（投影至当前运算对象的所有属性）。
3. 合并连续的选择与投影。投影应置于选择之后（之上）。
4. 将每个二元运算及作为其直接祖先的连续的一元运算合为一组，并合成出组内可能存在的连接运算。若该二元运算的某后代链上不存在二元运算（仅包含一系列一元运算），则将该后代链并入当前组。但**若该二元运算为笛卡尔积，且后代不能与其组成等值连接，则后代链须自成一组**。
5. 产生查询程序：程序自底至上以组为单位执行查询。

### 物理优化

物理查询运算符：关系代数操作的一种特定实现。物理优化通过选择较优的物理查询运算符实现。

DBA执行收集数据库的相关统计信息的实用程序，代价估算基于这些统计信息进行。

代价估算：在关系运算结果$E$产生前估算其元组数$T(E)$，某属性$A$不同值数目$V(E,A)$等统计信息。

- 在代价浮动于一定范围内时，通常使用均值估算。但**对于不等选择操作（例如$\sigma_{A<3}$），通常估算结果元组数为原关系元组数的$\dfrac 1 3$**；对于等于选择操作（例如$\sigma_{A=3}$），**简单估计**时可估计其结果元组数为原关系元组数的$\dfrac 1 {10}$。
  - 例如$\sigma_{A=10}(E)$结果元组数估计为$\dfrac {T(E)} {V(E,A)}$。
  - 例如$R(X,Y) \Join S(Y,Z)$结果元组数估计为$\dfrac {T(R)T(S)} {\max (V(R,Y),V(S,Y))}$。
- 对于多条件选择操作，通常将条件间视为相互独立，并计算期望。但对于逻辑或，若两条件估算结果相差悬殊，**简单估计**时可直接取其中较大值。

## 第22讲 数据库并发控制

典型不一致现象：

- 丢失修改：两事务并行读取与写入，仅其中一个写入结果被保留。
- 不能重复读：某事务假设数据不变，从而始终读取，此时另一事务对数据写入，导致数据被改变。
- 脏读：事务A修改数据后被事务B读取，而后事务A进行回滚，此时事务B持有的是错误数据。

事务：DBMS提供的一致地操作数据的一种手段。事务在宏观上独立完整，在微观上交错执行。

并发控制通过事务微观交错执行次序的正确安排，保证事务宏观的独立性、完整性和正确性。

事务的特性（ACID）：原子性、一致性、隔离性、持久性。参见第9-10讲。**具有ACID特性的若干数据库基本操作的组合体被称为事务**。

### 事务调度与可串行性

以下使用记号：$r_T(A)$表示事务$T$读$A$，$w_T(A)$表示事务$T$写$A$。

事务调度：一组事务的基本步的一种执行顺序。

- 串行调度：同一个事务的一系列基本步连续执行。
- 并发调度：多个事务宏观上并行执行，微观上交错执行。

正确的并行调度：存在一个串行调度，其结果与该并发调度下所得数据库结果相同。

可串行性：若对数据库的任意初始状态，一个调度对数据库状态的影响都与某个串行调度相同，则称该调度是可串行化的。正确的并行调度不一定是可串行化的，因为“正确的并行调度”只针对某一具体情形，而可串行性要求对所有初始状态均满足。

冲突：调度中一对连续的动作，若其顺序交换，则涉及的事务中至少有一个事务的行为将改变。

- 同一事务的任意两个操作是冲突的。
- 不同事务对同一元素的写操作是冲突的。
- 不同事物对同一元素的一读一写操作是冲突的。

冲突可串行性：若一个调度可通过交换相邻无冲突操作而转换到某一串行调度，则称该调度是冲突可串行化的。**冲突可串行性强于可串行性**。

冲突可串行性判别算法：对于有冲突的操作，根据其先后顺序在事务图（节点为事务）中连接有向边，然后判有向图是否无环。

### 基于锁的并发控制

锁本身不能保证冲突可串行性，锁为调度提供了控制的手段。

锁的类型：

- 排他锁$X$：仅有一个事务可读写。
- 共享锁$S$：所有事务均只读。
- 更新锁$U$：初始只读，之后可升级为写。
- 增量锁$I$：仅进行增量更新。

相容性矩阵：不同锁之间的兼容性，即已有一锁时是否可加另一锁。

封锁协议：

- 0级协议（读未提交）：写时加排他锁，不写后立即解锁。仅可防止丢失修改。
- 1级协议（读已提交）：写时加排他锁，事务提交时解锁。可防止丢失修改并**可恢复**。
- 2级协议（可重复读）：写时加排他锁，事务提交时解锁；读时加共享锁，不读后立即解锁。可防止丢失修改与脏读。
- 3级协议（可串行化）：写时加排他锁，事务提交时解锁；读时加共享锁，事务提交时解锁。可防止所有不一致性。

封锁粒度：封锁数据对象的大小。当前DBMS一般在元组粒度上加锁。

#### 两段封锁协议（2PL）

- 内容：每个事务中所有加锁请求应先于任何一个解锁请求。即加解锁严格分为两个阶段。

- 结果：可产生冲突可串行化调度。

- 证明：归纳法。设现需调度$n$个事务，其中事务$T_i$在所有事务中具有最早的解锁动作$U_i(X)$。

  假设协议对除$T_i$外的其余$n-1$个事务可产生冲突可串行化调度。

  反证法，考虑$T_i$的某个动作$w_i(Y)$，假设在其之前存在与其冲突的动作$w_j(Y)$，则调度中存在子序列：
  $$
  w_j(Y),U_i(X),U_j(Y),L_i(Y),w_i(Y)
  $$
  而这是不可能的，因为$U_i$出现在了$L_i$之前，违反了两端封锁协议。证毕。

### 基于时间戳的并发控制

时间戳：与时间对应的数值，具有唯一性与递增性。

简单策略：为每个数据元素维护一读时间戳，一写时间戳，分别表示最后一个读/写之的事务的时间戳。每当事务读写该数据元素时更新时间戳，但若发现冲突（在读-写、写-读、写-写情况中，后来者时间戳更小）则撤回事务，并重获取事务时间戳，重做。

托马斯写规则：后启动的事务先写时，先启动的事务在后写时本应被撤销，但实际上可忽略这次写来维持结果正确。

可实现托马斯写规则的策略：在简单策略基础上再为每一数据元素维护一提交位。每当事务写该元素时置其为0，每当写该元素的事务提交时置其为1。读数据时，若时间戳正确则等待数据元素提交位为真后读，否则需回滚。写数据时，若读时间戳不正确则回滚，若读时间戳正确而写时间戳不正确则等待数据元素提交位为真后决定忽略写或进行写，若写时间戳也正确则直接写入。

### 基于有效性确认的并发控制

事务分三阶段进行：读阶段，有效性确认阶段，写阶段。并发事务串行的顺序即有效性确认的顺序。

调度器维护START，VAL，FIN集合记录每个事物的开始时间、确认时间与结束时间。调度器也维护每个事务的读集合与写集合。

对事务$T$进行有效性确认的策略：对$T$开始后进行过写的事务，检查其写集合与$T$的读集合是否有交集，有则不确认。对$T$确认时仍未结束的事务，检查其写集合与$T$的写集合是否有交集，有则不确认。上述两情况都未出现时，确认$T$，否则回滚$T$。

## 第23讲 数据库故障恢复

故障恢复：将数据库由当前不正确的状态恢复为已知正确的某一状态，涉及到保证事务的**原子性**和**持久性**。

故障分类及恢复策略：

- 事务故障：事务自身错误导致，仅影响该事务本身。
  - 通过重做事务与撤销事务来恢复。
- 系统故障：掉电、非正常关机等故障，影响正在运行的事务以及数据库缓冲区（已经执行的事务）。
  - 通过运行日志进行恢复。
  - 运行日志：由DBMS维护，在事务每一次实际操作前记录操作内容。
  - 检查点：在一定的时刻，DBMS将内存缓冲区内容写回磁盘。DBMS仅需恢复检查点之后结束或发生的事务，其中故障点前已结束的事务应重做，而故障点时未结束的事务应撤销。
- 介质故障：介质（内存、磁盘等）损坏引起的故障。
  - 通过副本恢复，依据副本恢复后再依据运行日志进一步恢复转储点之后的操作。
  - 副本：数据库在其它介质上存储的一份等同记录。
  - 转储点：备份的时刻。注意日志要覆盖转储点之前的一部分数据，以保证顺畅衔接。

### 运行日志

缓冲区处理策略：

- Force：缓冲区数据最晚在提交时写入磁盘。
- No Steal：缓冲区数据最早在提交时写入磁盘。
- No Force：对最晚写入时间没有限制，由于提交后可能还未写入而系统故障，**需要Redo型日志**。
- Steal：对最早写入时间没有限制，由于写入后可能还未提交而系统故障，**需要Undo型日志**。

当前最常用的处理策略：Steal+No force

日志文件：只能追加的顺序文件，事务日志交错存储，按发生时间存储。

- 记录信息：事务的开始、完成、中止与写动作。即对数据的所有更新操作。

- 类型：Undo型，Redo型，Undo/Redo型。

- 检查点：周期性在日志中设置检查点，并将缓冲区内容写回磁盘。

  - 静止检查点：设置检查点后停止接受新事务，直至所有当前事务提交或中止后将日志刷新至磁盘，并向日志写入\<CKPT\>。

    恢复时只需恢复至\<CKPT\>即可结束。

  - 非静止检查点：向日志写入\<START CKPT(T)\>，其中T为当前未结束事务列表，并将所有已提交事务写回磁盘，随后继续正常操作，直至前述未结束事务全部结束时，向日志写入\<END CKPT\>。

    恢复时恢复至\<START CKPT\>。

- Undo型日志：

  - 记录：在事务开始时向日志写入\<START T\>，向日志写入\<T,X,v\>（事务，数据元素，**旧值**），向磁盘写入改动，在事务提交或中止时向日志写入\<COMMIT T\>或\<ABORT T\>。
  - 要求：写入磁盘前不能提交事务。
  - 恢复：从日志尾部向前扫描，撤销未完成事务的所有修改，直至遇到静止检查点或非静止检查点起始记录。

- Redo型日志：

  - 记录：在事务开始时向日志写入\<START T\>，向日志写入\<T,X,v\>（事务，数据元素，**新值**），在事务提交时先向日志写入\<COMMIT T\>，然后向磁盘写入改动。
  - 要求：提交事务前不能写入磁盘。
  - 恢复：从日志最后一个检查点起（若是非静止检查点则从其给出的最早开始的事务起）重做所有操作，但忽略未提交的事务。

- Undo/Redo型日志：

  - 记录：在事务开始时向日志写入\<START T\>，向日志写入\<T,X,u,v\>（事务，数据元素，**旧值**，**新值**），在事务提交时向日志写入\<COMMIT T\>，同时向磁盘写入改动（以上两写入不区分顺序）。
  - 恢复：自前向后重做所有已提交事务，自后向前撤销所有未完成事务。